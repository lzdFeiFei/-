# 函数

## 创建函数的三种方法

函数声明，函数声明提升

函数表达式 

箭头函数： 不能使用 arguments、super 和 new.target，不能作为构造函数，没有 prototype 属性

## 参数

函数的参数在内部表现为一个数组，函数被调用的时候总会接收一个数组，但并不关心数组中包含什么

### arguments 

类数组对象，callee —— 指向所在函数的指针，使用 arguments.callee 可以让函数逻辑和函数名解耦

### 默认参数

在使用默认参数时，arguments 对象的值不反应参数的默认值，只反映传给函数的参数；

默认参数并不限于原始值或对象类型， 也可以使用函数返回的值

### 扩展参数

调用时通过扩展运输符传参

### 收集参数

扩展运算符将独立参数组合为一个数组

### this 

非箭头函数，函数调用时的上下文对象；箭头函数，定义时的上下文

### new.target

检测函数是否是通过 new 关键字调用

### 函数属性与方法

属性 length prototype

方法 apply call

### 尾调用优化

确定外部栈帧没有必要存在了

- 严格模式
- 外部函数返回值是对尾调用函数的调用
- 尾调用函数返回后不需要执行额外的逻辑
- 尾调用函数不是引用外部函数作用域中自由变量的闭包

### 闭包

JavaScript中一个函数，如果访问了外层作用域的变量，那么它是一个闭包

严格来讲，所有 js 函数都是闭包，

值得注意的是定义函数与调用函数的作用域不同的时候，最常见的情形就是一个函数返回了在它内部定义的嵌套函数

要使用外部函数的 this ，箭头函数或者请将其设置给一个变量 例如 that self

### 纯函数

此函数在相同的输入值时，需产生相同的输出。

函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关。

该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。

确定的输入，一定会产生确定的输出；

函数在执行过程中，不能产生副作用；

### 柯里化

是把接收多个参数的函数，变成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数，而且返回 结果的新函数

职责单一 参数复用

自动柯里化

```js
function autoCurrying(fn) {
  function curried(...args){
    if(args.length >= fn.length){
      return fn.apply(this, args)
    }else{
      return function(...args2){
        return curried.apply(this, args.concat(args2))
      }
    }
  }
  return curried 
}
```



