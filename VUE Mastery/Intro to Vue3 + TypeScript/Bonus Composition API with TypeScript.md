# Bonus: Composition API with TypeScript

## Introduction

Welcome to the bonus lesson for this course! Now, while weâ€™ve been using the Options API for this entire course, I want you to know that everything youâ€™ve learned is just as relevant for the Composition API! So, letâ€™s jump right in shall we?

## Todo App Demo

To start, letâ€™s go ahead and check out our demo app.

![https://firebasestorage.googleapis.com/v0/b/vue-mastery.appspot.com/o/flamelink%2Fmedia%2F1.opt.1615249432795.jpg?alt=media&token=fa5523a2-622d-42d4-9bd0-002946517983](https://firebasestorage.googleapis.com/v0/b/vue-mastery.appspot.com/o/flamelink%2Fmedia%2F1.opt.1615249432795.jpg?alt=media&token=fa5523a2-622d-42d4-9bd0-002946517983)

Inside of the repo, Iâ€™ve scaffolded a temporary Todo page to demo Composition API with TypeScript. It is currently defined in `router/index.ts` and `views/Todo.vue`.

It allows you to do things such as:

- Define the task label
- Determine what type the task is
- Toggle the state of whether the task is complete
- Filter the current list of tasks based on whether it is complete or not.

### How It Is Built with Options API

When we open up `Todo.vue`, youâ€™ll see that we have the functionality already built using what weâ€™ve learned in this course using Options API and TypeScript.

We have two custom types that are defined in `types.ts`:

**ðŸ“„ types.ts**

```typescript
type TaskType = 'personal' | 'work' | 'miscellaneous'

export interface TodoItem {
  label: string
  type: TaskType
  isComplete: boolean
}
```

There is the custom type of `TaskType` which only takes:

1. personal
2. work
3. miscellaneous

And then thereâ€™s the custom interface of `TodoItem` which leverages our `TaskType` to help better define the shape of the data.

Inside of our single-file component, we have our reactive data that is being tracked inside the `data` option and is also properly typed:

- `newTask` is an object which should conform to our custom type `TodoItem`
- `taskItems` which contains an array of `TodoItem`

**ðŸ“„ views/Todo.vue**

```typescript
import { defineComponent } from 'vue'
import { TodoItem } from '../types'

export default defineComponent({
  data: () => ({
    newTask: {
      label: '',
      type: 'personal'
    } as TodoItem,
    taskItems: [] as TodoItem[],
    listFilter: 'all'
  }),
  ...
})
```

Then we also have our computed property which is also properly typed:

**ðŸ“„ views/Todo.vue**

```typescript
import { defineComponent } from 'vue'
import { TodoItem } from '../types'

export default defineComponent({
  // data option removed for brevity
  computed: {
    filteredTasks(): TodoItem[] {
      if (this.listFilter === 'complete') {
        return this.taskItems.filter(
          (item: TodoItem) => item.isComplete === true
        )
      } else if (this.listFilter === 'incomplete') {
        return this.taskItems.filter(
          (item: TodoItem) => item.isComplete === false
        )
      } else {
        return this.taskItems
      }
    }
  }
})
```

Here you can see that we define the return value of `filteredTasks`, which should be an array of `TodoItem`. In addition, youâ€™ll also notice that we are typing the argument being used in the `.filter` method so provide better developer experience with auto-detection of properties.

Now that weâ€™ve covered how it was built, letâ€™s refactor it using the Composition API!

If youâ€™re new to the Composition API, I recommend checking out Greggâ€™s course on [Vue 3 Composition API](https://www.vuemastery.com/courses/vue-3-essentials/why-the-composition-api/)

## Refactoring to Composition API

To start using the Composition API, we start by setting up our `setup` function:

**ðŸ“„ views/Todo.vue**

```typescript
import { defineComponent } from 'vue'
import { TodoItem } from '../types'

export default defineComponent({
  setup() {
    // Our code goes in here!
  }
})
```

Then, weâ€™ll go ahead and migrate our `data` option into our `setup` method using the `reactive` helper method, which is my personal preference as it mirrors closely to our existing mental model of how reactive data works with Vue.

```typescript
import { defineComponent, reactive } from 'vue'
import { TodoItem } from '../types'

export default defineComponent({
  setup() {
    const state = reactive({
      newTask: {
        label: '',
        type: 'personal'
      } as TodoItem,
      taskItems: [] as TodoItem[],
      listFilter: 'all'
    })

    return {
      state
    }
  }
})
```

As you can see, even though weâ€™re working in the Composition API, the types still work exactly as expected! No additional work needed!

Now we also want to clean up the need to reference `state` in our template, so letâ€™s use the `toRefs` helper method to allow us to destructure our state without breaking its reactivity.

```typescript
import { defineComponent, reactive, toRefs } from 'vue'
import { TodoItem } from '../types'

export default defineComponent({
  setup() {
    const state = reactive({
      newTask: {
        label: '',
        type: 'personal'
      } as TodoItem,
      taskItems: [] as TodoItem[],
      listFilter: 'all'
    })

    return {
      ...toRefs(state)
    }
  }
})
```

Next, weâ€™ll want to migrate our `computed` property, which we can do by using the `computed` helper method! Unlike the `data` option refactor though, thereâ€™s one big difference: thereâ€™s less code!

```typescript
import { defineComponent, reactive, toRefs } from 'vue'
import { TodoItem } from '../types'

export default defineComponent({
  setup() {
    const state = reactive({
      // Omitted for brevity
    })

    const filteredTasks = computed(() => {
      if (state.listFilter === 'complete') {
        return state.taskItems.filter(
          (item: TodoItem) => item.isComplete === true
        )
      } else if (state.listFilter === 'incomplete') {
        return state.taskItems.filter(
          (item: TodoItem) => item.isComplete === false
        )
      } else {
        return state.taskItems
      }
    })

    return {
      ...toRefs(state),
      filteredTasks
    }
  }
})
```

When defining types in computed properties in the Options API, we needed to be explicit about what was returned. However, when using the Composition API, you donâ€™t need to do that since TypeScript can infer the type thatâ€™s returned!

The final touch is to add the methods to our `setup` method, which we can do without any helper methods since a method is the equivalent of a standard JavaScript function.

```typescript
import { defineComponent, reactive, toRefs } from 'vue'
import { TodoItem } from '../types'

export default defineComponent({
  setup() {
    const state = reactive({
      newTask: {
        label: '',
        type: 'personal'
      } as TodoItem,
      taskItems: [] as TodoItem[],
      listFilter: 'all'
    })

    const filteredTasks = computed(() => {
      if (state.listFilter === 'complete') {
        return state.taskItems.filter(
          (item: TodoItem) => item.isComplete === true
        )
      } else if (state.listFilter === 'incomplete') {
        return state.taskItems.filter(
          (item: TodoItem) => item.isComplete === false
        )
      } else {
        return state.taskItems
      }
    })

    const addTask = () => {
      state.taskItems.push(state.newTask)
    }

    return {
      ...toRefs(state),
      addTask
      filteredTasks
    }
  }
})
```

And believe it or not, weâ€™re done!

## Letâ€™s ReVue

Alright. Letâ€™s review. For this lesson, weâ€™ve taken a look at how the experience between Options API and Composition API can be different TypeScript wise in that Composition API is more friendly to TypeScript, but at the end of the day, you can still apply the concepts you learned about in this course in both contexts.

Thanks for watching and learning Vue 3 and TypeScript with me!



https://github.com/Code-Pop/Real-World-Vue-3-TypeScript/tree/10-begin

https://github.com/Code-Pop/Real-World-Vue-3-TypeScript/tree/10-end